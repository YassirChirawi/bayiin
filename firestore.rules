rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // --- HELPERS ---

    // Get the signed-in user's data (cached by Firestore rules for same request)
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    // Check if the user belongs to the store they are trying to access
    function belongsToStore(storeId) {
       // Ideally, we verify against the user document, but for read speed rules
       // often rely on custom claims. Here we stick to document lookup as users are < 100 per store.
       return getUserData().storeId == storeId;
    }

    // Type Checks
    function isNumber(num) {
      return num is number || num is float || num is int;
    }
    
    function isString(str) {
      return str is string;
    }

    // --- VALIDATORS ---

    // Validate Store Write
    function isValidStoreUpdate(data) {
       // Must prevent editing 'subscriptionStatus' directly unless via Admin SDK (backend)
       // But owner might need to update logo/address.
       // We restrict 'plan' and 'subscriptionStatus' updates.
       return !data.diff(resource.data).affectedKeys().hasAny(['plan', 'subscriptionStatus', 'stripeCustomerId']);
    }

    // Validate Product
    function isValidProduct(data) {
       return data.storeId == getUserData().storeId &&
              data.name is string && data.name.size() > 0 &&
              isNumber(data.price) && data.price >= 0 &&
              isNumber(data.stock) &&
              (!("costPrice" in data) || (isNumber(data.costPrice) && data.costPrice >= 0));
    }

    // Validate Order
    function isValidOrder(data) {
       return data.storeId == getUserData().storeId &&
              isNumber(data.price) && data.price >= 0 &&
              isNumber(data.quantity) && data.quantity > 0 &&
              ("status" in data == false || data.status in ['reçu', 'confirmation', 'packing', 'ramassage', 'livraison', 'reporté', 'livré', 'retour', 'annulé']) &&
              (!("isPaid" in data) || data.isPaid is bool) &&
              (!("realDeliveryCost" in data) || (isNumber(data.realDeliveryCost) && data.realDeliveryCost >= 0));
    }

    // --- RULES ---

    // Users collection: Users can read/write their own profile
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Stores collection
    match /stores/{storeId} {
      // Create: Anyone auth'd can create a store (Signup)
      allow create: if request.auth != null;
      
      // Update: Only if it's THEIR store using 'belongsToStore'
      allow update: if request.auth != null && belongsToStore(storeId) && isValidStoreUpdate(request.resource.data);
      
      // Read: Only if it's THEIR store
      allow read: if request.auth != null && belongsToStore(storeId);
      
      // Stats Subcollection (Read-Only for Client)
      match /stats/{statId} {
         allow read: if request.auth != null && belongsToStore(storeId);
         allow write: if request.auth != null && belongsToStore(storeId);
      }
    }

    // Products
    match /products/{productId} {
       allow read: if request.auth != null && resource.data.storeId == getUserData().storeId;
       allow create: if request.auth != null && isValidProduct(request.resource.data);
       allow update: if request.auth != null && resource.data.storeId == getUserData().storeId && isValidProduct(request.resource.data);
       allow delete: if request.auth != null && resource.data.storeId == getUserData().storeId;
    }
    
    // Orders
    match /orders/{orderId} {
       allow read: if request.auth != null && resource.data.storeId == getUserData().storeId;
       allow create: if request.auth != null && isValidOrder(request.resource.data);
       allow update: if request.auth != null && resource.data.storeId == getUserData().storeId && isValidOrder(request.resource.data);
       allow delete: if request.auth != null && resource.data.storeId == getUserData().storeId;
    }

    // Expenses
    match /expenses/{expenseId} {
       allow read: if request.auth != null && resource.data.storeId == getUserData().storeId;
       allow create: if request.auth != null && 
                     request.resource.data.storeId == getUserData().storeId &&
                     isNumber(request.resource.data.amount);
       allow update, delete: if request.auth != null && resource.data.storeId == getUserData().storeId;
    }

    // Customers
    match /customers/{customerId} {
       allow read: if request.auth != null && resource.data.storeId == getUserData().storeId;
       allow create: if request.auth != null && request.resource.data.storeId == getUserData().storeId;
       allow update, delete: if request.auth != null && resource.data.storeId == getUserData().storeId;
    }

    // Team Management
    match /allowed_users/{userId} {
       allow read: if request.auth != null && resource.data.email == request.auth.token.email;
       allow read: if request.auth != null && belongsToStore(resource.data.storeId);
       
       // Only the store owner should invite? Or anyone in the store? Assuming Store Owner logic elsewhere, but generally safer:
       allow create, delete: if request.auth != null && belongsToStore(request.resource.data.storeId); 
    }

    // Public Leads / Waiting List (Strictly Create Only)
    match /leads/{leadId} {
       allow create: if true; // Public can create
       allow read, update, delete: if false; // No one can read/edit via Client SDK
    }
  }
}
